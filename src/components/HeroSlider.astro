---
interface Props {
  slideCount: number;
  autoplayInterval?: number;
}

const { slideCount, autoplayInterval = 5000 } = Astro.props;
---

<hero-slider
  data-autoplay-interval={autoplayInterval}
  data-animate-class="animate-hero-progress-fill"
  class="block w-full group/slider"
>
  <div class="relative w-full">
    <div class="relative min-h-112 lg:min-h-128 overflow-hidden">
      <div
        class="absolute bottom-6 left-1/2 -translate-x-1/2 flex gap-2 z-10 bg-white/80 backdrop-blur-sm rounded-full p-1"
        role="tablist"
        aria-label="Slides del hero"
      >
        {
          Array.from({ length: slideCount }, (_, i) => (
            <button
              type="button"
              class="hero-indicator group flex items-center justify-center p-1 focus-ring"
              aria-label={`Ir al slide ${i + 1}`}
              aria-selected={i === 0 ? "true" : "false"}
              role="tab"
              data-indicator
              data-index={i}
            >
              <span
                class="h-2.5 w-2.5 rounded-full overflow-hidden bg-navy-blue/20 flex shrink-0 transition-[width] duration-300 ease-out group-hover:bg-navy-blue/30 group-aria-selected:w-8"
                aria-hidden="true"
              >
                <span
                  class="block h-full min-w-0 w-0 rounded-full bg-french-ultramarine/60 group-data-[paused]/slider:[animation-play-state:paused]"
                  data-progress-fill
                  aria-hidden="true"
                  class:list={[i === 0 && "animate-hero-progress-fill"]}
                />
              </span>
            </button>
          ))
        }
      </div>
      <slot />
    </div>
  </div>
</hero-slider>

<script>
  class HeroSlider extends HTMLElement {
    #autoplayTimer: ReturnType<typeof setInterval> | null = null;
    #isPaused = false;

    connectedCallback() {
      const interval = Number(this.dataset.autoplayInterval) || 5000;
      const animateClass =
        this.dataset.animateClass || "animate-hero-progress-fill";

      const slides = this.querySelectorAll<HTMLElement>("[data-slide]");
      const indicators =
        this.querySelectorAll<HTMLButtonElement>("[data-indicator]");

      this.style.setProperty("--hero-progress-duration", `${interval}ms`);

      let currentIndex = 0;

      const playEntranceAnimations = (slideIndex: number) => {
        const slide = slides[slideIndex];
        slide.querySelectorAll<HTMLElement>("[data-animate]").forEach((el) => {
          el.classList.remove("animate-slide-in-up");
          void el.offsetWidth;
          el.style.animationDelay = `${el.dataset.animateDelay ?? 0}ms`;
          el.classList.add("animate-slide-in-up");
        });
      };

      const restartProgressAnimation = () => {
        const fill = indicators[currentIndex]?.querySelector<HTMLElement>(
          "[data-progress-fill]",
        );
        if (fill) {
          fill.classList.remove(animateClass);
          void fill.offsetHeight;
          fill.classList.add(animateClass);
        }
      };

      const goToSlide = (index: number) => {
        currentIndex =
          ((index % slides.length) + slides.length) % slides.length;

        slides.forEach((slide, i) => {
          slide.setAttribute("aria-hidden", String(i !== currentIndex));
          slide.toggleAttribute("data-active", i === currentIndex);
        });

        indicators.forEach((ind, i) => {
          const isActive = i === currentIndex;
          ind.setAttribute("aria-selected", String(isActive));
          ind
            .querySelector<HTMLElement>("[data-progress-fill]")
            ?.classList.toggle(animateClass, isActive);
        });

        restartProgressAnimation();
        playEntranceAnimations(currentIndex);
      };

      const startAutoplay = () => {
        this.removeAttribute("data-paused");
        if (this.#autoplayTimer) clearInterval(this.#autoplayTimer);
        this.#autoplayTimer = setInterval(() => {
          if (!this.#isPaused) goToSlide(currentIndex + 1);
        }, interval);
        restartProgressAnimation();
      };

      const stopAutoplay = () => {
        this.setAttribute("data-paused", "");
        if (this.#autoplayTimer) {
          clearInterval(this.#autoplayTimer);
          this.#autoplayTimer = null;
        }
      };

      indicators.forEach((ind, i) => {
        ind.addEventListener("click", () => {
          goToSlide(i);
          this.#isPaused = true;
          stopAutoplay();
        });
      });

      this.addEventListener("mouseenter", () => {
        this.#isPaused = true;
        stopAutoplay();
      });
      this.addEventListener("mouseleave", () => {
        this.#isPaused = false;
        startAutoplay();
      });
      this.addEventListener("focusin", () => {
        this.#isPaused = true;
        stopAutoplay();
      });
      this.addEventListener("focusout", () => {
        if (!this.contains(document.activeElement)) {
          this.#isPaused = false;
          startAutoplay();
        }
      });

      playEntranceAnimations(0);
      startAutoplay();
    }

    disconnectedCallback() {
      if (this.#autoplayTimer) clearInterval(this.#autoplayTimer);
    }
  }

  customElements.define("hero-slider", HeroSlider);
</script>
