---
interface Props {
  slideCount: number;
  autoplayInterval?: number;
}

const { slideCount, autoplayInterval = 5000 } = Astro.props;
---

<hero-slider
  data-autoplay-interval={autoplayInterval}
  data-animate-class="animate-hero-progress-fill"
  class="block w-full group/slider"
>
  <div class="relative w-full">
    <div class="relative h-170 lg:h-130 overflow-hidden">
      <div
        class="absolute bottom-6 left-1/2 -translate-x-1/2 flex gap-2 z-10 bg-white/80 backdrop-blur-sm rounded-full p-1"
        role="tablist"
        aria-label="Slides del hero"
      >
        {
          Array.from({ length: slideCount }, (_, i) => (
            <button
              type="button"
              class="hero-indicator group flex items-center justify-center p-1 focus-ring"
              aria-label={`Ir al slide ${i + 1}`}
              aria-selected={i === 0 ? "true" : "false"}
              role="tab"
              data-indicator
              data-index={i}
            >
              <span
                class="h-2.5 w-2.5 rounded-full overflow-hidden bg-navy-blue/20 flex shrink-0 transition-[width] duration-300 ease-out group-hover:bg-navy-blue/30 group-aria-selected:w-8"
                aria-hidden="true"
              >
                <span
                  class="block h-full min-w-0 w-0 rounded-full bg-french-ultramarine/60 group-data-[paused]/slider:[animation-play-state:paused]"
                  data-progress-fill
                  aria-hidden="true"
                  class:list={[i === 0 && "animate-hero-progress-fill"]}
                />
              </span>
            </button>
          ))
        }
      </div>
      <slot />
    </div>
  </div>
</hero-slider>

<script>
  class HeroSlider extends HTMLElement {
    #timeout: ReturnType<typeof setTimeout> | null = null;
    #idleTimeout: ReturnType<typeof setTimeout> | null = null;
    #remaining = 0;
    #epochStart = 0;
    #isHovering = false;
    #isFocused = false;

    connectedCallback() {
      const interval = Number(this.dataset.autoplayInterval) || 5000;
      const animateClass =
        this.dataset.animateClass || "animate-hero-progress-fill";
      const IDLE_MS = 300;

      const slides = this.querySelectorAll<HTMLElement>("[data-slide]");
      const indicators =
        this.querySelectorAll<HTMLButtonElement>("[data-indicator]");

      this.style.setProperty("--hero-progress-duration", `${interval}ms`);

      let currentIndex = 0;

      const playEntranceAnimations = (slideIndex: number) => {
        const slide = slides[slideIndex];
        slide.querySelectorAll<HTMLElement>("[data-animate]").forEach((el) => {
          el.classList.remove("animate-slide-in-up");
          void el.offsetWidth;
          el.style.animationDelay = `${el.dataset.animateDelay ?? 0}ms`;
          el.classList.add("animate-slide-in-up");
        });
      };

      const restartProgressAnimation = () => {
        const fill = indicators[currentIndex]?.querySelector<HTMLElement>(
          "[data-progress-fill]",
        );
        if (fill) {
          fill.classList.remove(animateClass);
          void fill.offsetHeight;
          fill.classList.add(animateClass);
        }
      };

      const goToSlide = (index: number) => {
        currentIndex =
          ((index % slides.length) + slides.length) % slides.length;

        slides.forEach((slide, i) => {
          slide.setAttribute("aria-hidden", String(i !== currentIndex));
          slide.toggleAttribute("data-active", i === currentIndex);
        });

        indicators.forEach((ind, i) => {
          const isActive = i === currentIndex;
          ind.setAttribute("aria-selected", String(isActive));
          ind
            .querySelector<HTMLElement>("[data-progress-fill]")
            ?.classList.toggle(animateClass, isActive);
        });

        restartProgressAnimation();
        playEntranceAnimations(currentIndex);
      };

      /* ── Resumable timer ─────────────────────────────────── */

      const clearSchedule = () => {
        if (this.#timeout) {
          clearTimeout(this.#timeout);
          this.#timeout = null;
        }
      };

      const schedule = (delay: number) => {
        clearSchedule();
        this.#remaining = delay;
        this.#epochStart = performance.now();
        this.removeAttribute("data-paused");
        this.#timeout = setTimeout(() => {
          goToSlide(currentIndex + 1);
          schedule(interval);
        }, delay);
      };

      const pause = () => {
        if (!this.#timeout) return;
        clearSchedule();
        this.#remaining = Math.max(
          0,
          this.#remaining - (performance.now() - this.#epochStart),
        );
        this.setAttribute("data-paused", "");
      };

      const resume = () => {
        if (this.#isFocused) return;
        if (this.#remaining <= 0) {
          goToSlide(currentIndex + 1);
          schedule(interval);
        } else {
          schedule(this.#remaining);
        }
      };

      /* ── Mouse-idle detection ────────────────────────────── */

      const clearIdle = () => {
        if (this.#idleTimeout) {
          clearTimeout(this.#idleTimeout);
          this.#idleTimeout = null;
        }
      };

      const resetIdle = () => {
        clearIdle();
        this.#idleTimeout = setTimeout(() => {
          if (this.#isHovering && !this.#isFocused) resume();
        }, IDLE_MS);
      };

      /* ── Indicator clicks ────────────────────────────────── */

      indicators.forEach((ind, i) => {
        ind.addEventListener("click", () => {
          goToSlide(i);
          schedule(interval);
          if (this.#isHovering || this.#isFocused) {
            pause();
            if (this.#isHovering && !this.#isFocused) resetIdle();
          }
        });
      });

      /* ── Hover: pause while moving, resume when idle ─────── */

      this.addEventListener("mouseenter", () => {
        this.#isHovering = true;
        pause();
        resetIdle();
      });

      this.addEventListener("mousemove", () => {
        if (!this.#isHovering) return;
        if (this.#timeout) pause();
        resetIdle();
      });

      this.addEventListener("mouseleave", () => {
        this.#isHovering = false;
        clearIdle();
        if (!this.#isFocused) resume();
      });

      /* ── Focus (keyboard / assistive tech) ───────────────── */

      this.addEventListener("focusin", () => {
        this.#isFocused = true;
        clearIdle();
        pause();
      });

      this.addEventListener("focusout", () => {
        if (this.contains(document.activeElement)) return;
        this.#isFocused = false;
        if (this.#isHovering) {
          resetIdle();
        } else {
          resume();
        }
      });

      /* ── Init ────────────────────────────────────────────── */

      playEntranceAnimations(0);
      schedule(interval);
    }

    disconnectedCallback() {
      if (this.#timeout) clearTimeout(this.#timeout);
      if (this.#idleTimeout) clearTimeout(this.#idleTimeout);
    }
  }

  customElements.define("hero-slider", HeroSlider);
</script>
